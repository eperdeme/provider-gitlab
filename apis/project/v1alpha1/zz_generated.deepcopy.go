//go:build !ignore_autogenerated

/*
Copyright 2022 Upbound Inc.
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/crossplane/crossplane-runtime/apis/common/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ContainerExpirationPolicyInitParameters) DeepCopyInto(out *ContainerExpirationPolicyInitParameters) {
	*out = *in
	if in.Cadence != nil {
		in, out := &in.Cadence, &out.Cadence
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.KeepN != nil {
		in, out := &in.KeepN, &out.KeepN
		*out = new(float64)
		**out = **in
	}
	if in.NameRegex != nil {
		in, out := &in.NameRegex, &out.NameRegex
		*out = new(string)
		**out = **in
	}
	if in.NameRegexDelete != nil {
		in, out := &in.NameRegexDelete, &out.NameRegexDelete
		*out = new(string)
		**out = **in
	}
	if in.NameRegexKeep != nil {
		in, out := &in.NameRegexKeep, &out.NameRegexKeep
		*out = new(string)
		**out = **in
	}
	if in.OlderThan != nil {
		in, out := &in.OlderThan, &out.OlderThan
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ContainerExpirationPolicyInitParameters.
func (in *ContainerExpirationPolicyInitParameters) DeepCopy() *ContainerExpirationPolicyInitParameters {
	if in == nil {
		return nil
	}
	out := new(ContainerExpirationPolicyInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ContainerExpirationPolicyObservation) DeepCopyInto(out *ContainerExpirationPolicyObservation) {
	*out = *in
	if in.Cadence != nil {
		in, out := &in.Cadence, &out.Cadence
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.KeepN != nil {
		in, out := &in.KeepN, &out.KeepN
		*out = new(float64)
		**out = **in
	}
	if in.NameRegex != nil {
		in, out := &in.NameRegex, &out.NameRegex
		*out = new(string)
		**out = **in
	}
	if in.NameRegexDelete != nil {
		in, out := &in.NameRegexDelete, &out.NameRegexDelete
		*out = new(string)
		**out = **in
	}
	if in.NameRegexKeep != nil {
		in, out := &in.NameRegexKeep, &out.NameRegexKeep
		*out = new(string)
		**out = **in
	}
	if in.NextRunAt != nil {
		in, out := &in.NextRunAt, &out.NextRunAt
		*out = new(string)
		**out = **in
	}
	if in.OlderThan != nil {
		in, out := &in.OlderThan, &out.OlderThan
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ContainerExpirationPolicyObservation.
func (in *ContainerExpirationPolicyObservation) DeepCopy() *ContainerExpirationPolicyObservation {
	if in == nil {
		return nil
	}
	out := new(ContainerExpirationPolicyObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ContainerExpirationPolicyParameters) DeepCopyInto(out *ContainerExpirationPolicyParameters) {
	*out = *in
	if in.Cadence != nil {
		in, out := &in.Cadence, &out.Cadence
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.KeepN != nil {
		in, out := &in.KeepN, &out.KeepN
		*out = new(float64)
		**out = **in
	}
	if in.NameRegex != nil {
		in, out := &in.NameRegex, &out.NameRegex
		*out = new(string)
		**out = **in
	}
	if in.NameRegexDelete != nil {
		in, out := &in.NameRegexDelete, &out.NameRegexDelete
		*out = new(string)
		**out = **in
	}
	if in.NameRegexKeep != nil {
		in, out := &in.NameRegexKeep, &out.NameRegexKeep
		*out = new(string)
		**out = **in
	}
	if in.OlderThan != nil {
		in, out := &in.OlderThan, &out.OlderThan
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ContainerExpirationPolicyParameters.
func (in *ContainerExpirationPolicyParameters) DeepCopy() *ContainerExpirationPolicyParameters {
	if in == nil {
		return nil
	}
	out := new(ContainerExpirationPolicyParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Project) DeepCopyInto(out *Project) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Project.
func (in *Project) DeepCopy() *Project {
	if in == nil {
		return nil
	}
	out := new(Project)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Project) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectInitParameters) DeepCopyInto(out *ProjectInitParameters) {
	*out = *in
	if in.AllowMergeOnSkippedPipeline != nil {
		in, out := &in.AllowMergeOnSkippedPipeline, &out.AllowMergeOnSkippedPipeline
		*out = new(bool)
		**out = **in
	}
	if in.AnalyticsAccessLevel != nil {
		in, out := &in.AnalyticsAccessLevel, &out.AnalyticsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ApprovalsBeforeMerge != nil {
		in, out := &in.ApprovalsBeforeMerge, &out.ApprovalsBeforeMerge
		*out = new(float64)
		**out = **in
	}
	if in.ArchiveOnDestroy != nil {
		in, out := &in.ArchiveOnDestroy, &out.ArchiveOnDestroy
		*out = new(bool)
		**out = **in
	}
	if in.Archived != nil {
		in, out := &in.Archived, &out.Archived
		*out = new(bool)
		**out = **in
	}
	if in.AutoCancelPendingPipelines != nil {
		in, out := &in.AutoCancelPendingPipelines, &out.AutoCancelPendingPipelines
		*out = new(string)
		**out = **in
	}
	if in.AutoDevopsDeployStrategy != nil {
		in, out := &in.AutoDevopsDeployStrategy, &out.AutoDevopsDeployStrategy
		*out = new(string)
		**out = **in
	}
	if in.AutoDevopsEnabled != nil {
		in, out := &in.AutoDevopsEnabled, &out.AutoDevopsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AutocloseReferencedIssues != nil {
		in, out := &in.AutocloseReferencedIssues, &out.AutocloseReferencedIssues
		*out = new(bool)
		**out = **in
	}
	if in.Avatar != nil {
		in, out := &in.Avatar, &out.Avatar
		*out = new(string)
		**out = **in
	}
	if in.AvatarHash != nil {
		in, out := &in.AvatarHash, &out.AvatarHash
		*out = new(string)
		**out = **in
	}
	if in.BuildCoverageRegex != nil {
		in, out := &in.BuildCoverageRegex, &out.BuildCoverageRegex
		*out = new(string)
		**out = **in
	}
	if in.BuildGitStrategy != nil {
		in, out := &in.BuildGitStrategy, &out.BuildGitStrategy
		*out = new(string)
		**out = **in
	}
	if in.BuildTimeout != nil {
		in, out := &in.BuildTimeout, &out.BuildTimeout
		*out = new(float64)
		**out = **in
	}
	if in.BuildsAccessLevel != nil {
		in, out := &in.BuildsAccessLevel, &out.BuildsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.CiConfigPath != nil {
		in, out := &in.CiConfigPath, &out.CiConfigPath
		*out = new(string)
		**out = **in
	}
	if in.CiDefaultGitDepth != nil {
		in, out := &in.CiDefaultGitDepth, &out.CiDefaultGitDepth
		*out = new(float64)
		**out = **in
	}
	if in.CiForwardDeploymentEnabled != nil {
		in, out := &in.CiForwardDeploymentEnabled, &out.CiForwardDeploymentEnabled
		*out = new(bool)
		**out = **in
	}
	if in.CiRestrictPipelineCancellationRole != nil {
		in, out := &in.CiRestrictPipelineCancellationRole, &out.CiRestrictPipelineCancellationRole
		*out = new(string)
		**out = **in
	}
	if in.CiSeparatedCaches != nil {
		in, out := &in.CiSeparatedCaches, &out.CiSeparatedCaches
		*out = new(bool)
		**out = **in
	}
	if in.ContainerExpirationPolicy != nil {
		in, out := &in.ContainerExpirationPolicy, &out.ContainerExpirationPolicy
		*out = make([]ContainerExpirationPolicyInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ContainerRegistryAccessLevel != nil {
		in, out := &in.ContainerRegistryAccessLevel, &out.ContainerRegistryAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ContainerRegistryEnabled != nil {
		in, out := &in.ContainerRegistryEnabled, &out.ContainerRegistryEnabled
		*out = new(bool)
		**out = **in
	}
	if in.DefaultBranch != nil {
		in, out := &in.DefaultBranch, &out.DefaultBranch
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.EmailsEnabled != nil {
		in, out := &in.EmailsEnabled, &out.EmailsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.EnvironmentsAccessLevel != nil {
		in, out := &in.EnvironmentsAccessLevel, &out.EnvironmentsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ExternalAuthorizationClassificationLabel != nil {
		in, out := &in.ExternalAuthorizationClassificationLabel, &out.ExternalAuthorizationClassificationLabel
		*out = new(string)
		**out = **in
	}
	if in.FeatureFlagsAccessLevel != nil {
		in, out := &in.FeatureFlagsAccessLevel, &out.FeatureFlagsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ForkedFromProjectID != nil {
		in, out := &in.ForkedFromProjectID, &out.ForkedFromProjectID
		*out = new(float64)
		**out = **in
	}
	if in.ForkingAccessLevel != nil {
		in, out := &in.ForkingAccessLevel, &out.ForkingAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.GroupRunnersEnabled != nil {
		in, out := &in.GroupRunnersEnabled, &out.GroupRunnersEnabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupWithProjectTemplatesID != nil {
		in, out := &in.GroupWithProjectTemplatesID, &out.GroupWithProjectTemplatesID
		*out = new(float64)
		**out = **in
	}
	if in.ImportURL != nil {
		in, out := &in.ImportURL, &out.ImportURL
		*out = new(string)
		**out = **in
	}
	if in.ImportURLUsername != nil {
		in, out := &in.ImportURLUsername, &out.ImportURLUsername
		*out = new(string)
		**out = **in
	}
	if in.InfrastructureAccessLevel != nil {
		in, out := &in.InfrastructureAccessLevel, &out.InfrastructureAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.InitializeWithReadme != nil {
		in, out := &in.InitializeWithReadme, &out.InitializeWithReadme
		*out = new(bool)
		**out = **in
	}
	if in.IssuesAccessLevel != nil {
		in, out := &in.IssuesAccessLevel, &out.IssuesAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.IssuesEnabled != nil {
		in, out := &in.IssuesEnabled, &out.IssuesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.IssuesTemplate != nil {
		in, out := &in.IssuesTemplate, &out.IssuesTemplate
		*out = new(string)
		**out = **in
	}
	if in.KeepLatestArtifact != nil {
		in, out := &in.KeepLatestArtifact, &out.KeepLatestArtifact
		*out = new(bool)
		**out = **in
	}
	if in.LfsEnabled != nil {
		in, out := &in.LfsEnabled, &out.LfsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MergeCommitTemplate != nil {
		in, out := &in.MergeCommitTemplate, &out.MergeCommitTemplate
		*out = new(string)
		**out = **in
	}
	if in.MergeMethod != nil {
		in, out := &in.MergeMethod, &out.MergeMethod
		*out = new(string)
		**out = **in
	}
	if in.MergePipelinesEnabled != nil {
		in, out := &in.MergePipelinesEnabled, &out.MergePipelinesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MergeRequestsAccessLevel != nil {
		in, out := &in.MergeRequestsAccessLevel, &out.MergeRequestsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.MergeRequestsEnabled != nil {
		in, out := &in.MergeRequestsEnabled, &out.MergeRequestsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MergeRequestsTemplate != nil {
		in, out := &in.MergeRequestsTemplate, &out.MergeRequestsTemplate
		*out = new(string)
		**out = **in
	}
	if in.MergeTrainsEnabled != nil {
		in, out := &in.MergeTrainsEnabled, &out.MergeTrainsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Mirror != nil {
		in, out := &in.Mirror, &out.Mirror
		*out = new(bool)
		**out = **in
	}
	if in.MirrorOverwritesDivergedBranches != nil {
		in, out := &in.MirrorOverwritesDivergedBranches, &out.MirrorOverwritesDivergedBranches
		*out = new(bool)
		**out = **in
	}
	if in.MirrorTriggerBuilds != nil {
		in, out := &in.MirrorTriggerBuilds, &out.MirrorTriggerBuilds
		*out = new(bool)
		**out = **in
	}
	if in.MonitorAccessLevel != nil {
		in, out := &in.MonitorAccessLevel, &out.MonitorAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.MrDefaultTargetSelf != nil {
		in, out := &in.MrDefaultTargetSelf, &out.MrDefaultTargetSelf
		*out = new(bool)
		**out = **in
	}
	if in.NamespaceID != nil {
		in, out := &in.NamespaceID, &out.NamespaceID
		*out = new(float64)
		**out = **in
	}
	if in.OnlyAllowMergeIfAllDiscussionsAreResolved != nil {
		in, out := &in.OnlyAllowMergeIfAllDiscussionsAreResolved, &out.OnlyAllowMergeIfAllDiscussionsAreResolved
		*out = new(bool)
		**out = **in
	}
	if in.OnlyAllowMergeIfPipelineSucceeds != nil {
		in, out := &in.OnlyAllowMergeIfPipelineSucceeds, &out.OnlyAllowMergeIfPipelineSucceeds
		*out = new(bool)
		**out = **in
	}
	if in.OnlyMirrorProtectedBranches != nil {
		in, out := &in.OnlyMirrorProtectedBranches, &out.OnlyMirrorProtectedBranches
		*out = new(bool)
		**out = **in
	}
	if in.PackagesEnabled != nil {
		in, out := &in.PackagesEnabled, &out.PackagesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PagesAccessLevel != nil {
		in, out := &in.PagesAccessLevel, &out.PagesAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.Path != nil {
		in, out := &in.Path, &out.Path
		*out = new(string)
		**out = **in
	}
	if in.PipelinesEnabled != nil {
		in, out := &in.PipelinesEnabled, &out.PipelinesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PrintingMergeRequestLinkEnabled != nil {
		in, out := &in.PrintingMergeRequestLinkEnabled, &out.PrintingMergeRequestLinkEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PublicBuilds != nil {
		in, out := &in.PublicBuilds, &out.PublicBuilds
		*out = new(bool)
		**out = **in
	}
	if in.PublicJobs != nil {
		in, out := &in.PublicJobs, &out.PublicJobs
		*out = new(bool)
		**out = **in
	}
	if in.PushRules != nil {
		in, out := &in.PushRules, &out.PushRules
		*out = make([]PushRulesInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ReleasesAccessLevel != nil {
		in, out := &in.ReleasesAccessLevel, &out.ReleasesAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.RemoveSourceBranchAfterMerge != nil {
		in, out := &in.RemoveSourceBranchAfterMerge, &out.RemoveSourceBranchAfterMerge
		*out = new(bool)
		**out = **in
	}
	if in.RepositoryAccessLevel != nil {
		in, out := &in.RepositoryAccessLevel, &out.RepositoryAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.RepositoryStorage != nil {
		in, out := &in.RepositoryStorage, &out.RepositoryStorage
		*out = new(string)
		**out = **in
	}
	if in.RequestAccessEnabled != nil {
		in, out := &in.RequestAccessEnabled, &out.RequestAccessEnabled
		*out = new(bool)
		**out = **in
	}
	if in.RequirementsAccessLevel != nil {
		in, out := &in.RequirementsAccessLevel, &out.RequirementsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ResolveOutdatedDiffDiscussions != nil {
		in, out := &in.ResolveOutdatedDiffDiscussions, &out.ResolveOutdatedDiffDiscussions
		*out = new(bool)
		**out = **in
	}
	if in.RestrictUserDefinedVariables != nil {
		in, out := &in.RestrictUserDefinedVariables, &out.RestrictUserDefinedVariables
		*out = new(bool)
		**out = **in
	}
	if in.SecurityAndComplianceAccessLevel != nil {
		in, out := &in.SecurityAndComplianceAccessLevel, &out.SecurityAndComplianceAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.SharedRunnersEnabled != nil {
		in, out := &in.SharedRunnersEnabled, &out.SharedRunnersEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SkipWaitForDefaultBranchProtection != nil {
		in, out := &in.SkipWaitForDefaultBranchProtection, &out.SkipWaitForDefaultBranchProtection
		*out = new(bool)
		**out = **in
	}
	if in.SnippetsAccessLevel != nil {
		in, out := &in.SnippetsAccessLevel, &out.SnippetsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.SnippetsEnabled != nil {
		in, out := &in.SnippetsEnabled, &out.SnippetsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SquashCommitTemplate != nil {
		in, out := &in.SquashCommitTemplate, &out.SquashCommitTemplate
		*out = new(string)
		**out = **in
	}
	if in.SquashOption != nil {
		in, out := &in.SquashOption, &out.SquashOption
		*out = new(string)
		**out = **in
	}
	if in.SuggestionCommitMessage != nil {
		in, out := &in.SuggestionCommitMessage, &out.SuggestionCommitMessage
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TemplateName != nil {
		in, out := &in.TemplateName, &out.TemplateName
		*out = new(string)
		**out = **in
	}
	if in.TemplateProjectID != nil {
		in, out := &in.TemplateProjectID, &out.TemplateProjectID
		*out = new(float64)
		**out = **in
	}
	if in.Topics != nil {
		in, out := &in.Topics, &out.Topics
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.UseCustomTemplate != nil {
		in, out := &in.UseCustomTemplate, &out.UseCustomTemplate
		*out = new(bool)
		**out = **in
	}
	if in.VisibilityLevel != nil {
		in, out := &in.VisibilityLevel, &out.VisibilityLevel
		*out = new(string)
		**out = **in
	}
	if in.WikiAccessLevel != nil {
		in, out := &in.WikiAccessLevel, &out.WikiAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.WikiEnabled != nil {
		in, out := &in.WikiEnabled, &out.WikiEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectInitParameters.
func (in *ProjectInitParameters) DeepCopy() *ProjectInitParameters {
	if in == nil {
		return nil
	}
	out := new(ProjectInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectList) DeepCopyInto(out *ProjectList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Project, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectList.
func (in *ProjectList) DeepCopy() *ProjectList {
	if in == nil {
		return nil
	}
	out := new(ProjectList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ProjectList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectObservation) DeepCopyInto(out *ProjectObservation) {
	*out = *in
	if in.AllowMergeOnSkippedPipeline != nil {
		in, out := &in.AllowMergeOnSkippedPipeline, &out.AllowMergeOnSkippedPipeline
		*out = new(bool)
		**out = **in
	}
	if in.AnalyticsAccessLevel != nil {
		in, out := &in.AnalyticsAccessLevel, &out.AnalyticsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ApprovalsBeforeMerge != nil {
		in, out := &in.ApprovalsBeforeMerge, &out.ApprovalsBeforeMerge
		*out = new(float64)
		**out = **in
	}
	if in.ArchiveOnDestroy != nil {
		in, out := &in.ArchiveOnDestroy, &out.ArchiveOnDestroy
		*out = new(bool)
		**out = **in
	}
	if in.Archived != nil {
		in, out := &in.Archived, &out.Archived
		*out = new(bool)
		**out = **in
	}
	if in.AutoCancelPendingPipelines != nil {
		in, out := &in.AutoCancelPendingPipelines, &out.AutoCancelPendingPipelines
		*out = new(string)
		**out = **in
	}
	if in.AutoDevopsDeployStrategy != nil {
		in, out := &in.AutoDevopsDeployStrategy, &out.AutoDevopsDeployStrategy
		*out = new(string)
		**out = **in
	}
	if in.AutoDevopsEnabled != nil {
		in, out := &in.AutoDevopsEnabled, &out.AutoDevopsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AutocloseReferencedIssues != nil {
		in, out := &in.AutocloseReferencedIssues, &out.AutocloseReferencedIssues
		*out = new(bool)
		**out = **in
	}
	if in.Avatar != nil {
		in, out := &in.Avatar, &out.Avatar
		*out = new(string)
		**out = **in
	}
	if in.AvatarHash != nil {
		in, out := &in.AvatarHash, &out.AvatarHash
		*out = new(string)
		**out = **in
	}
	if in.AvatarURL != nil {
		in, out := &in.AvatarURL, &out.AvatarURL
		*out = new(string)
		**out = **in
	}
	if in.BuildCoverageRegex != nil {
		in, out := &in.BuildCoverageRegex, &out.BuildCoverageRegex
		*out = new(string)
		**out = **in
	}
	if in.BuildGitStrategy != nil {
		in, out := &in.BuildGitStrategy, &out.BuildGitStrategy
		*out = new(string)
		**out = **in
	}
	if in.BuildTimeout != nil {
		in, out := &in.BuildTimeout, &out.BuildTimeout
		*out = new(float64)
		**out = **in
	}
	if in.BuildsAccessLevel != nil {
		in, out := &in.BuildsAccessLevel, &out.BuildsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.CiConfigPath != nil {
		in, out := &in.CiConfigPath, &out.CiConfigPath
		*out = new(string)
		**out = **in
	}
	if in.CiDefaultGitDepth != nil {
		in, out := &in.CiDefaultGitDepth, &out.CiDefaultGitDepth
		*out = new(float64)
		**out = **in
	}
	if in.CiForwardDeploymentEnabled != nil {
		in, out := &in.CiForwardDeploymentEnabled, &out.CiForwardDeploymentEnabled
		*out = new(bool)
		**out = **in
	}
	if in.CiRestrictPipelineCancellationRole != nil {
		in, out := &in.CiRestrictPipelineCancellationRole, &out.CiRestrictPipelineCancellationRole
		*out = new(string)
		**out = **in
	}
	if in.CiSeparatedCaches != nil {
		in, out := &in.CiSeparatedCaches, &out.CiSeparatedCaches
		*out = new(bool)
		**out = **in
	}
	if in.ContainerExpirationPolicy != nil {
		in, out := &in.ContainerExpirationPolicy, &out.ContainerExpirationPolicy
		*out = make([]ContainerExpirationPolicyObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ContainerRegistryAccessLevel != nil {
		in, out := &in.ContainerRegistryAccessLevel, &out.ContainerRegistryAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ContainerRegistryEnabled != nil {
		in, out := &in.ContainerRegistryEnabled, &out.ContainerRegistryEnabled
		*out = new(bool)
		**out = **in
	}
	if in.DefaultBranch != nil {
		in, out := &in.DefaultBranch, &out.DefaultBranch
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.EmailsEnabled != nil {
		in, out := &in.EmailsEnabled, &out.EmailsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.EmptyRepo != nil {
		in, out := &in.EmptyRepo, &out.EmptyRepo
		*out = new(bool)
		**out = **in
	}
	if in.EnvironmentsAccessLevel != nil {
		in, out := &in.EnvironmentsAccessLevel, &out.EnvironmentsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ExternalAuthorizationClassificationLabel != nil {
		in, out := &in.ExternalAuthorizationClassificationLabel, &out.ExternalAuthorizationClassificationLabel
		*out = new(string)
		**out = **in
	}
	if in.FeatureFlagsAccessLevel != nil {
		in, out := &in.FeatureFlagsAccessLevel, &out.FeatureFlagsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ForkedFromProjectID != nil {
		in, out := &in.ForkedFromProjectID, &out.ForkedFromProjectID
		*out = new(float64)
		**out = **in
	}
	if in.ForkingAccessLevel != nil {
		in, out := &in.ForkingAccessLevel, &out.ForkingAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.GroupRunnersEnabled != nil {
		in, out := &in.GroupRunnersEnabled, &out.GroupRunnersEnabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupWithProjectTemplatesID != nil {
		in, out := &in.GroupWithProjectTemplatesID, &out.GroupWithProjectTemplatesID
		*out = new(float64)
		**out = **in
	}
	if in.HTTPURLToRepo != nil {
		in, out := &in.HTTPURLToRepo, &out.HTTPURLToRepo
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.ImportURL != nil {
		in, out := &in.ImportURL, &out.ImportURL
		*out = new(string)
		**out = **in
	}
	if in.ImportURLUsername != nil {
		in, out := &in.ImportURLUsername, &out.ImportURLUsername
		*out = new(string)
		**out = **in
	}
	if in.InfrastructureAccessLevel != nil {
		in, out := &in.InfrastructureAccessLevel, &out.InfrastructureAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.InitializeWithReadme != nil {
		in, out := &in.InitializeWithReadme, &out.InitializeWithReadme
		*out = new(bool)
		**out = **in
	}
	if in.IssuesAccessLevel != nil {
		in, out := &in.IssuesAccessLevel, &out.IssuesAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.IssuesEnabled != nil {
		in, out := &in.IssuesEnabled, &out.IssuesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.IssuesTemplate != nil {
		in, out := &in.IssuesTemplate, &out.IssuesTemplate
		*out = new(string)
		**out = **in
	}
	if in.KeepLatestArtifact != nil {
		in, out := &in.KeepLatestArtifact, &out.KeepLatestArtifact
		*out = new(bool)
		**out = **in
	}
	if in.LfsEnabled != nil {
		in, out := &in.LfsEnabled, &out.LfsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MergeCommitTemplate != nil {
		in, out := &in.MergeCommitTemplate, &out.MergeCommitTemplate
		*out = new(string)
		**out = **in
	}
	if in.MergeMethod != nil {
		in, out := &in.MergeMethod, &out.MergeMethod
		*out = new(string)
		**out = **in
	}
	if in.MergePipelinesEnabled != nil {
		in, out := &in.MergePipelinesEnabled, &out.MergePipelinesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MergeRequestsAccessLevel != nil {
		in, out := &in.MergeRequestsAccessLevel, &out.MergeRequestsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.MergeRequestsEnabled != nil {
		in, out := &in.MergeRequestsEnabled, &out.MergeRequestsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MergeRequestsTemplate != nil {
		in, out := &in.MergeRequestsTemplate, &out.MergeRequestsTemplate
		*out = new(string)
		**out = **in
	}
	if in.MergeTrainsEnabled != nil {
		in, out := &in.MergeTrainsEnabled, &out.MergeTrainsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Mirror != nil {
		in, out := &in.Mirror, &out.Mirror
		*out = new(bool)
		**out = **in
	}
	if in.MirrorOverwritesDivergedBranches != nil {
		in, out := &in.MirrorOverwritesDivergedBranches, &out.MirrorOverwritesDivergedBranches
		*out = new(bool)
		**out = **in
	}
	if in.MirrorTriggerBuilds != nil {
		in, out := &in.MirrorTriggerBuilds, &out.MirrorTriggerBuilds
		*out = new(bool)
		**out = **in
	}
	if in.MonitorAccessLevel != nil {
		in, out := &in.MonitorAccessLevel, &out.MonitorAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.MrDefaultTargetSelf != nil {
		in, out := &in.MrDefaultTargetSelf, &out.MrDefaultTargetSelf
		*out = new(bool)
		**out = **in
	}
	if in.NamespaceID != nil {
		in, out := &in.NamespaceID, &out.NamespaceID
		*out = new(float64)
		**out = **in
	}
	if in.OnlyAllowMergeIfAllDiscussionsAreResolved != nil {
		in, out := &in.OnlyAllowMergeIfAllDiscussionsAreResolved, &out.OnlyAllowMergeIfAllDiscussionsAreResolved
		*out = new(bool)
		**out = **in
	}
	if in.OnlyAllowMergeIfPipelineSucceeds != nil {
		in, out := &in.OnlyAllowMergeIfPipelineSucceeds, &out.OnlyAllowMergeIfPipelineSucceeds
		*out = new(bool)
		**out = **in
	}
	if in.OnlyMirrorProtectedBranches != nil {
		in, out := &in.OnlyMirrorProtectedBranches, &out.OnlyMirrorProtectedBranches
		*out = new(bool)
		**out = **in
	}
	if in.PackagesEnabled != nil {
		in, out := &in.PackagesEnabled, &out.PackagesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PagesAccessLevel != nil {
		in, out := &in.PagesAccessLevel, &out.PagesAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.Path != nil {
		in, out := &in.Path, &out.Path
		*out = new(string)
		**out = **in
	}
	if in.PathWithNamespace != nil {
		in, out := &in.PathWithNamespace, &out.PathWithNamespace
		*out = new(string)
		**out = **in
	}
	if in.PipelinesEnabled != nil {
		in, out := &in.PipelinesEnabled, &out.PipelinesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PrintingMergeRequestLinkEnabled != nil {
		in, out := &in.PrintingMergeRequestLinkEnabled, &out.PrintingMergeRequestLinkEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PublicBuilds != nil {
		in, out := &in.PublicBuilds, &out.PublicBuilds
		*out = new(bool)
		**out = **in
	}
	if in.PublicJobs != nil {
		in, out := &in.PublicJobs, &out.PublicJobs
		*out = new(bool)
		**out = **in
	}
	if in.PushRules != nil {
		in, out := &in.PushRules, &out.PushRules
		*out = make([]PushRulesObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ReleasesAccessLevel != nil {
		in, out := &in.ReleasesAccessLevel, &out.ReleasesAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.RemoveSourceBranchAfterMerge != nil {
		in, out := &in.RemoveSourceBranchAfterMerge, &out.RemoveSourceBranchAfterMerge
		*out = new(bool)
		**out = **in
	}
	if in.RepositoryAccessLevel != nil {
		in, out := &in.RepositoryAccessLevel, &out.RepositoryAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.RepositoryStorage != nil {
		in, out := &in.RepositoryStorage, &out.RepositoryStorage
		*out = new(string)
		**out = **in
	}
	if in.RequestAccessEnabled != nil {
		in, out := &in.RequestAccessEnabled, &out.RequestAccessEnabled
		*out = new(bool)
		**out = **in
	}
	if in.RequirementsAccessLevel != nil {
		in, out := &in.RequirementsAccessLevel, &out.RequirementsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ResolveOutdatedDiffDiscussions != nil {
		in, out := &in.ResolveOutdatedDiffDiscussions, &out.ResolveOutdatedDiffDiscussions
		*out = new(bool)
		**out = **in
	}
	if in.RestrictUserDefinedVariables != nil {
		in, out := &in.RestrictUserDefinedVariables, &out.RestrictUserDefinedVariables
		*out = new(bool)
		**out = **in
	}
	if in.SSHURLToRepo != nil {
		in, out := &in.SSHURLToRepo, &out.SSHURLToRepo
		*out = new(string)
		**out = **in
	}
	if in.SecurityAndComplianceAccessLevel != nil {
		in, out := &in.SecurityAndComplianceAccessLevel, &out.SecurityAndComplianceAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.SharedRunnersEnabled != nil {
		in, out := &in.SharedRunnersEnabled, &out.SharedRunnersEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SkipWaitForDefaultBranchProtection != nil {
		in, out := &in.SkipWaitForDefaultBranchProtection, &out.SkipWaitForDefaultBranchProtection
		*out = new(bool)
		**out = **in
	}
	if in.SnippetsAccessLevel != nil {
		in, out := &in.SnippetsAccessLevel, &out.SnippetsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.SnippetsEnabled != nil {
		in, out := &in.SnippetsEnabled, &out.SnippetsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SquashCommitTemplate != nil {
		in, out := &in.SquashCommitTemplate, &out.SquashCommitTemplate
		*out = new(string)
		**out = **in
	}
	if in.SquashOption != nil {
		in, out := &in.SquashOption, &out.SquashOption
		*out = new(string)
		**out = **in
	}
	if in.SuggestionCommitMessage != nil {
		in, out := &in.SuggestionCommitMessage, &out.SuggestionCommitMessage
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TemplateName != nil {
		in, out := &in.TemplateName, &out.TemplateName
		*out = new(string)
		**out = **in
	}
	if in.TemplateProjectID != nil {
		in, out := &in.TemplateProjectID, &out.TemplateProjectID
		*out = new(float64)
		**out = **in
	}
	if in.Topics != nil {
		in, out := &in.Topics, &out.Topics
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.UseCustomTemplate != nil {
		in, out := &in.UseCustomTemplate, &out.UseCustomTemplate
		*out = new(bool)
		**out = **in
	}
	if in.VisibilityLevel != nil {
		in, out := &in.VisibilityLevel, &out.VisibilityLevel
		*out = new(string)
		**out = **in
	}
	if in.WebURL != nil {
		in, out := &in.WebURL, &out.WebURL
		*out = new(string)
		**out = **in
	}
	if in.WikiAccessLevel != nil {
		in, out := &in.WikiAccessLevel, &out.WikiAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.WikiEnabled != nil {
		in, out := &in.WikiEnabled, &out.WikiEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectObservation.
func (in *ProjectObservation) DeepCopy() *ProjectObservation {
	if in == nil {
		return nil
	}
	out := new(ProjectObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectParameters) DeepCopyInto(out *ProjectParameters) {
	*out = *in
	if in.AllowMergeOnSkippedPipeline != nil {
		in, out := &in.AllowMergeOnSkippedPipeline, &out.AllowMergeOnSkippedPipeline
		*out = new(bool)
		**out = **in
	}
	if in.AnalyticsAccessLevel != nil {
		in, out := &in.AnalyticsAccessLevel, &out.AnalyticsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ApprovalsBeforeMerge != nil {
		in, out := &in.ApprovalsBeforeMerge, &out.ApprovalsBeforeMerge
		*out = new(float64)
		**out = **in
	}
	if in.ArchiveOnDestroy != nil {
		in, out := &in.ArchiveOnDestroy, &out.ArchiveOnDestroy
		*out = new(bool)
		**out = **in
	}
	if in.Archived != nil {
		in, out := &in.Archived, &out.Archived
		*out = new(bool)
		**out = **in
	}
	if in.AutoCancelPendingPipelines != nil {
		in, out := &in.AutoCancelPendingPipelines, &out.AutoCancelPendingPipelines
		*out = new(string)
		**out = **in
	}
	if in.AutoDevopsDeployStrategy != nil {
		in, out := &in.AutoDevopsDeployStrategy, &out.AutoDevopsDeployStrategy
		*out = new(string)
		**out = **in
	}
	if in.AutoDevopsEnabled != nil {
		in, out := &in.AutoDevopsEnabled, &out.AutoDevopsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AutocloseReferencedIssues != nil {
		in, out := &in.AutocloseReferencedIssues, &out.AutocloseReferencedIssues
		*out = new(bool)
		**out = **in
	}
	if in.Avatar != nil {
		in, out := &in.Avatar, &out.Avatar
		*out = new(string)
		**out = **in
	}
	if in.AvatarHash != nil {
		in, out := &in.AvatarHash, &out.AvatarHash
		*out = new(string)
		**out = **in
	}
	if in.BuildCoverageRegex != nil {
		in, out := &in.BuildCoverageRegex, &out.BuildCoverageRegex
		*out = new(string)
		**out = **in
	}
	if in.BuildGitStrategy != nil {
		in, out := &in.BuildGitStrategy, &out.BuildGitStrategy
		*out = new(string)
		**out = **in
	}
	if in.BuildTimeout != nil {
		in, out := &in.BuildTimeout, &out.BuildTimeout
		*out = new(float64)
		**out = **in
	}
	if in.BuildsAccessLevel != nil {
		in, out := &in.BuildsAccessLevel, &out.BuildsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.CiConfigPath != nil {
		in, out := &in.CiConfigPath, &out.CiConfigPath
		*out = new(string)
		**out = **in
	}
	if in.CiDefaultGitDepth != nil {
		in, out := &in.CiDefaultGitDepth, &out.CiDefaultGitDepth
		*out = new(float64)
		**out = **in
	}
	if in.CiForwardDeploymentEnabled != nil {
		in, out := &in.CiForwardDeploymentEnabled, &out.CiForwardDeploymentEnabled
		*out = new(bool)
		**out = **in
	}
	if in.CiRestrictPipelineCancellationRole != nil {
		in, out := &in.CiRestrictPipelineCancellationRole, &out.CiRestrictPipelineCancellationRole
		*out = new(string)
		**out = **in
	}
	if in.CiSeparatedCaches != nil {
		in, out := &in.CiSeparatedCaches, &out.CiSeparatedCaches
		*out = new(bool)
		**out = **in
	}
	if in.ContainerExpirationPolicy != nil {
		in, out := &in.ContainerExpirationPolicy, &out.ContainerExpirationPolicy
		*out = make([]ContainerExpirationPolicyParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ContainerRegistryAccessLevel != nil {
		in, out := &in.ContainerRegistryAccessLevel, &out.ContainerRegistryAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ContainerRegistryEnabled != nil {
		in, out := &in.ContainerRegistryEnabled, &out.ContainerRegistryEnabled
		*out = new(bool)
		**out = **in
	}
	if in.DefaultBranch != nil {
		in, out := &in.DefaultBranch, &out.DefaultBranch
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.EmailsEnabled != nil {
		in, out := &in.EmailsEnabled, &out.EmailsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.EnvironmentsAccessLevel != nil {
		in, out := &in.EnvironmentsAccessLevel, &out.EnvironmentsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ExternalAuthorizationClassificationLabel != nil {
		in, out := &in.ExternalAuthorizationClassificationLabel, &out.ExternalAuthorizationClassificationLabel
		*out = new(string)
		**out = **in
	}
	if in.FeatureFlagsAccessLevel != nil {
		in, out := &in.FeatureFlagsAccessLevel, &out.FeatureFlagsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ForkedFromProjectID != nil {
		in, out := &in.ForkedFromProjectID, &out.ForkedFromProjectID
		*out = new(float64)
		**out = **in
	}
	if in.ForkingAccessLevel != nil {
		in, out := &in.ForkingAccessLevel, &out.ForkingAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.GroupRunnersEnabled != nil {
		in, out := &in.GroupRunnersEnabled, &out.GroupRunnersEnabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupWithProjectTemplatesID != nil {
		in, out := &in.GroupWithProjectTemplatesID, &out.GroupWithProjectTemplatesID
		*out = new(float64)
		**out = **in
	}
	if in.ImportURL != nil {
		in, out := &in.ImportURL, &out.ImportURL
		*out = new(string)
		**out = **in
	}
	if in.ImportURLPasswordSecretRef != nil {
		in, out := &in.ImportURLPasswordSecretRef, &out.ImportURLPasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.ImportURLUsername != nil {
		in, out := &in.ImportURLUsername, &out.ImportURLUsername
		*out = new(string)
		**out = **in
	}
	if in.InfrastructureAccessLevel != nil {
		in, out := &in.InfrastructureAccessLevel, &out.InfrastructureAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.InitializeWithReadme != nil {
		in, out := &in.InitializeWithReadme, &out.InitializeWithReadme
		*out = new(bool)
		**out = **in
	}
	if in.IssuesAccessLevel != nil {
		in, out := &in.IssuesAccessLevel, &out.IssuesAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.IssuesEnabled != nil {
		in, out := &in.IssuesEnabled, &out.IssuesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.IssuesTemplate != nil {
		in, out := &in.IssuesTemplate, &out.IssuesTemplate
		*out = new(string)
		**out = **in
	}
	if in.KeepLatestArtifact != nil {
		in, out := &in.KeepLatestArtifact, &out.KeepLatestArtifact
		*out = new(bool)
		**out = **in
	}
	if in.LfsEnabled != nil {
		in, out := &in.LfsEnabled, &out.LfsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MergeCommitTemplate != nil {
		in, out := &in.MergeCommitTemplate, &out.MergeCommitTemplate
		*out = new(string)
		**out = **in
	}
	if in.MergeMethod != nil {
		in, out := &in.MergeMethod, &out.MergeMethod
		*out = new(string)
		**out = **in
	}
	if in.MergePipelinesEnabled != nil {
		in, out := &in.MergePipelinesEnabled, &out.MergePipelinesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MergeRequestsAccessLevel != nil {
		in, out := &in.MergeRequestsAccessLevel, &out.MergeRequestsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.MergeRequestsEnabled != nil {
		in, out := &in.MergeRequestsEnabled, &out.MergeRequestsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MergeRequestsTemplate != nil {
		in, out := &in.MergeRequestsTemplate, &out.MergeRequestsTemplate
		*out = new(string)
		**out = **in
	}
	if in.MergeTrainsEnabled != nil {
		in, out := &in.MergeTrainsEnabled, &out.MergeTrainsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Mirror != nil {
		in, out := &in.Mirror, &out.Mirror
		*out = new(bool)
		**out = **in
	}
	if in.MirrorOverwritesDivergedBranches != nil {
		in, out := &in.MirrorOverwritesDivergedBranches, &out.MirrorOverwritesDivergedBranches
		*out = new(bool)
		**out = **in
	}
	if in.MirrorTriggerBuilds != nil {
		in, out := &in.MirrorTriggerBuilds, &out.MirrorTriggerBuilds
		*out = new(bool)
		**out = **in
	}
	if in.MonitorAccessLevel != nil {
		in, out := &in.MonitorAccessLevel, &out.MonitorAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.MrDefaultTargetSelf != nil {
		in, out := &in.MrDefaultTargetSelf, &out.MrDefaultTargetSelf
		*out = new(bool)
		**out = **in
	}
	if in.NamespaceID != nil {
		in, out := &in.NamespaceID, &out.NamespaceID
		*out = new(float64)
		**out = **in
	}
	if in.OnlyAllowMergeIfAllDiscussionsAreResolved != nil {
		in, out := &in.OnlyAllowMergeIfAllDiscussionsAreResolved, &out.OnlyAllowMergeIfAllDiscussionsAreResolved
		*out = new(bool)
		**out = **in
	}
	if in.OnlyAllowMergeIfPipelineSucceeds != nil {
		in, out := &in.OnlyAllowMergeIfPipelineSucceeds, &out.OnlyAllowMergeIfPipelineSucceeds
		*out = new(bool)
		**out = **in
	}
	if in.OnlyMirrorProtectedBranches != nil {
		in, out := &in.OnlyMirrorProtectedBranches, &out.OnlyMirrorProtectedBranches
		*out = new(bool)
		**out = **in
	}
	if in.PackagesEnabled != nil {
		in, out := &in.PackagesEnabled, &out.PackagesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PagesAccessLevel != nil {
		in, out := &in.PagesAccessLevel, &out.PagesAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.Path != nil {
		in, out := &in.Path, &out.Path
		*out = new(string)
		**out = **in
	}
	if in.PipelinesEnabled != nil {
		in, out := &in.PipelinesEnabled, &out.PipelinesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PrintingMergeRequestLinkEnabled != nil {
		in, out := &in.PrintingMergeRequestLinkEnabled, &out.PrintingMergeRequestLinkEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PublicBuilds != nil {
		in, out := &in.PublicBuilds, &out.PublicBuilds
		*out = new(bool)
		**out = **in
	}
	if in.PublicJobs != nil {
		in, out := &in.PublicJobs, &out.PublicJobs
		*out = new(bool)
		**out = **in
	}
	if in.PushRules != nil {
		in, out := &in.PushRules, &out.PushRules
		*out = make([]PushRulesParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ReleasesAccessLevel != nil {
		in, out := &in.ReleasesAccessLevel, &out.ReleasesAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.RemoveSourceBranchAfterMerge != nil {
		in, out := &in.RemoveSourceBranchAfterMerge, &out.RemoveSourceBranchAfterMerge
		*out = new(bool)
		**out = **in
	}
	if in.RepositoryAccessLevel != nil {
		in, out := &in.RepositoryAccessLevel, &out.RepositoryAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.RepositoryStorage != nil {
		in, out := &in.RepositoryStorage, &out.RepositoryStorage
		*out = new(string)
		**out = **in
	}
	if in.RequestAccessEnabled != nil {
		in, out := &in.RequestAccessEnabled, &out.RequestAccessEnabled
		*out = new(bool)
		**out = **in
	}
	if in.RequirementsAccessLevel != nil {
		in, out := &in.RequirementsAccessLevel, &out.RequirementsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ResolveOutdatedDiffDiscussions != nil {
		in, out := &in.ResolveOutdatedDiffDiscussions, &out.ResolveOutdatedDiffDiscussions
		*out = new(bool)
		**out = **in
	}
	if in.RestrictUserDefinedVariables != nil {
		in, out := &in.RestrictUserDefinedVariables, &out.RestrictUserDefinedVariables
		*out = new(bool)
		**out = **in
	}
	if in.SecurityAndComplianceAccessLevel != nil {
		in, out := &in.SecurityAndComplianceAccessLevel, &out.SecurityAndComplianceAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.SharedRunnersEnabled != nil {
		in, out := &in.SharedRunnersEnabled, &out.SharedRunnersEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SkipWaitForDefaultBranchProtection != nil {
		in, out := &in.SkipWaitForDefaultBranchProtection, &out.SkipWaitForDefaultBranchProtection
		*out = new(bool)
		**out = **in
	}
	if in.SnippetsAccessLevel != nil {
		in, out := &in.SnippetsAccessLevel, &out.SnippetsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.SnippetsEnabled != nil {
		in, out := &in.SnippetsEnabled, &out.SnippetsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SquashCommitTemplate != nil {
		in, out := &in.SquashCommitTemplate, &out.SquashCommitTemplate
		*out = new(string)
		**out = **in
	}
	if in.SquashOption != nil {
		in, out := &in.SquashOption, &out.SquashOption
		*out = new(string)
		**out = **in
	}
	if in.SuggestionCommitMessage != nil {
		in, out := &in.SuggestionCommitMessage, &out.SuggestionCommitMessage
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TemplateName != nil {
		in, out := &in.TemplateName, &out.TemplateName
		*out = new(string)
		**out = **in
	}
	if in.TemplateProjectID != nil {
		in, out := &in.TemplateProjectID, &out.TemplateProjectID
		*out = new(float64)
		**out = **in
	}
	if in.Topics != nil {
		in, out := &in.Topics, &out.Topics
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.UseCustomTemplate != nil {
		in, out := &in.UseCustomTemplate, &out.UseCustomTemplate
		*out = new(bool)
		**out = **in
	}
	if in.VisibilityLevel != nil {
		in, out := &in.VisibilityLevel, &out.VisibilityLevel
		*out = new(string)
		**out = **in
	}
	if in.WikiAccessLevel != nil {
		in, out := &in.WikiAccessLevel, &out.WikiAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.WikiEnabled != nil {
		in, out := &in.WikiEnabled, &out.WikiEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectParameters.
func (in *ProjectParameters) DeepCopy() *ProjectParameters {
	if in == nil {
		return nil
	}
	out := new(ProjectParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectSpec) DeepCopyInto(out *ProjectSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectSpec.
func (in *ProjectSpec) DeepCopy() *ProjectSpec {
	if in == nil {
		return nil
	}
	out := new(ProjectSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectStatus) DeepCopyInto(out *ProjectStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectStatus.
func (in *ProjectStatus) DeepCopy() *ProjectStatus {
	if in == nil {
		return nil
	}
	out := new(ProjectStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PushRulesInitParameters) DeepCopyInto(out *PushRulesInitParameters) {
	*out = *in
	if in.AuthorEmailRegex != nil {
		in, out := &in.AuthorEmailRegex, &out.AuthorEmailRegex
		*out = new(string)
		**out = **in
	}
	if in.BranchNameRegex != nil {
		in, out := &in.BranchNameRegex, &out.BranchNameRegex
		*out = new(string)
		**out = **in
	}
	if in.CommitCommitterCheck != nil {
		in, out := &in.CommitCommitterCheck, &out.CommitCommitterCheck
		*out = new(bool)
		**out = **in
	}
	if in.CommitCommitterNameCheck != nil {
		in, out := &in.CommitCommitterNameCheck, &out.CommitCommitterNameCheck
		*out = new(bool)
		**out = **in
	}
	if in.CommitMessageNegativeRegex != nil {
		in, out := &in.CommitMessageNegativeRegex, &out.CommitMessageNegativeRegex
		*out = new(string)
		**out = **in
	}
	if in.CommitMessageRegex != nil {
		in, out := &in.CommitMessageRegex, &out.CommitMessageRegex
		*out = new(string)
		**out = **in
	}
	if in.DenyDeleteTag != nil {
		in, out := &in.DenyDeleteTag, &out.DenyDeleteTag
		*out = new(bool)
		**out = **in
	}
	if in.FileNameRegex != nil {
		in, out := &in.FileNameRegex, &out.FileNameRegex
		*out = new(string)
		**out = **in
	}
	if in.MaxFileSize != nil {
		in, out := &in.MaxFileSize, &out.MaxFileSize
		*out = new(float64)
		**out = **in
	}
	if in.MemberCheck != nil {
		in, out := &in.MemberCheck, &out.MemberCheck
		*out = new(bool)
		**out = **in
	}
	if in.PreventSecrets != nil {
		in, out := &in.PreventSecrets, &out.PreventSecrets
		*out = new(bool)
		**out = **in
	}
	if in.RejectUnsignedCommits != nil {
		in, out := &in.RejectUnsignedCommits, &out.RejectUnsignedCommits
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PushRulesInitParameters.
func (in *PushRulesInitParameters) DeepCopy() *PushRulesInitParameters {
	if in == nil {
		return nil
	}
	out := new(PushRulesInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PushRulesObservation) DeepCopyInto(out *PushRulesObservation) {
	*out = *in
	if in.AuthorEmailRegex != nil {
		in, out := &in.AuthorEmailRegex, &out.AuthorEmailRegex
		*out = new(string)
		**out = **in
	}
	if in.BranchNameRegex != nil {
		in, out := &in.BranchNameRegex, &out.BranchNameRegex
		*out = new(string)
		**out = **in
	}
	if in.CommitCommitterCheck != nil {
		in, out := &in.CommitCommitterCheck, &out.CommitCommitterCheck
		*out = new(bool)
		**out = **in
	}
	if in.CommitCommitterNameCheck != nil {
		in, out := &in.CommitCommitterNameCheck, &out.CommitCommitterNameCheck
		*out = new(bool)
		**out = **in
	}
	if in.CommitMessageNegativeRegex != nil {
		in, out := &in.CommitMessageNegativeRegex, &out.CommitMessageNegativeRegex
		*out = new(string)
		**out = **in
	}
	if in.CommitMessageRegex != nil {
		in, out := &in.CommitMessageRegex, &out.CommitMessageRegex
		*out = new(string)
		**out = **in
	}
	if in.DenyDeleteTag != nil {
		in, out := &in.DenyDeleteTag, &out.DenyDeleteTag
		*out = new(bool)
		**out = **in
	}
	if in.FileNameRegex != nil {
		in, out := &in.FileNameRegex, &out.FileNameRegex
		*out = new(string)
		**out = **in
	}
	if in.MaxFileSize != nil {
		in, out := &in.MaxFileSize, &out.MaxFileSize
		*out = new(float64)
		**out = **in
	}
	if in.MemberCheck != nil {
		in, out := &in.MemberCheck, &out.MemberCheck
		*out = new(bool)
		**out = **in
	}
	if in.PreventSecrets != nil {
		in, out := &in.PreventSecrets, &out.PreventSecrets
		*out = new(bool)
		**out = **in
	}
	if in.RejectUnsignedCommits != nil {
		in, out := &in.RejectUnsignedCommits, &out.RejectUnsignedCommits
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PushRulesObservation.
func (in *PushRulesObservation) DeepCopy() *PushRulesObservation {
	if in == nil {
		return nil
	}
	out := new(PushRulesObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PushRulesParameters) DeepCopyInto(out *PushRulesParameters) {
	*out = *in
	if in.AuthorEmailRegex != nil {
		in, out := &in.AuthorEmailRegex, &out.AuthorEmailRegex
		*out = new(string)
		**out = **in
	}
	if in.BranchNameRegex != nil {
		in, out := &in.BranchNameRegex, &out.BranchNameRegex
		*out = new(string)
		**out = **in
	}
	if in.CommitCommitterCheck != nil {
		in, out := &in.CommitCommitterCheck, &out.CommitCommitterCheck
		*out = new(bool)
		**out = **in
	}
	if in.CommitCommitterNameCheck != nil {
		in, out := &in.CommitCommitterNameCheck, &out.CommitCommitterNameCheck
		*out = new(bool)
		**out = **in
	}
	if in.CommitMessageNegativeRegex != nil {
		in, out := &in.CommitMessageNegativeRegex, &out.CommitMessageNegativeRegex
		*out = new(string)
		**out = **in
	}
	if in.CommitMessageRegex != nil {
		in, out := &in.CommitMessageRegex, &out.CommitMessageRegex
		*out = new(string)
		**out = **in
	}
	if in.DenyDeleteTag != nil {
		in, out := &in.DenyDeleteTag, &out.DenyDeleteTag
		*out = new(bool)
		**out = **in
	}
	if in.FileNameRegex != nil {
		in, out := &in.FileNameRegex, &out.FileNameRegex
		*out = new(string)
		**out = **in
	}
	if in.MaxFileSize != nil {
		in, out := &in.MaxFileSize, &out.MaxFileSize
		*out = new(float64)
		**out = **in
	}
	if in.MemberCheck != nil {
		in, out := &in.MemberCheck, &out.MemberCheck
		*out = new(bool)
		**out = **in
	}
	if in.PreventSecrets != nil {
		in, out := &in.PreventSecrets, &out.PreventSecrets
		*out = new(bool)
		**out = **in
	}
	if in.RejectUnsignedCommits != nil {
		in, out := &in.RejectUnsignedCommits, &out.RejectUnsignedCommits
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PushRulesParameters.
func (in *PushRulesParameters) DeepCopy() *PushRulesParameters {
	if in == nil {
		return nil
	}
	out := new(PushRulesParameters)
	in.DeepCopyInto(out)
	return out
}
